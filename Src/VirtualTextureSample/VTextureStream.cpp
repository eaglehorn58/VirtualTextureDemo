//	Copyright(c) 2020, Andy Du, All Rights Reserved.
// 	Contact: eaglehorn58@gmail.com


#include "Global.h"
#include "VTextureSystem.h"
#include "VTextureStream.h"
#include "DirectXTex.h"
#include "AFileWrapper.h"
#include "AFI.h"

///////////////////////////////////////////////////////////////////////////

#define VTFILE_VERSION	1

///////////////////////////////////////////////////////////////////////////

struct VTFILE_HEADER
{
	auint32		ver;
	int			iVTexSize;		//	border width of virtual texture (mipmap 0)
	int			iVPageSize;		//	border width of virtual page
	int			iIndirTexSize;	//	indirect texture size (mipmap 0)
	int			iPixelBytes;	//	bytes per pixel
	int			iMipmapCnt;		//	mipmap count
	int			iNumOriginTex;	//	number of original textures
	int			fmtVT;			//	original texture format
};

///////////////////////////////////////////////////////////////////////////

//	Write pixel data of one mipmap level to vt file
//	width: width (height) of vt in pixels
//	pitch: row pitch of vt in bytes
bool WriteMipmapData(AFileWrapper& file, const void* pData, int width, int iPixelBytes, int pitch, int iVPageSize)
{
	MyAssert(width >= iVPageSize && width % iVPageSize == 0);

	int iBlockCnt = width / iVPageSize;
	int iBlockPitch = iVPageSize * iPixelBytes;

	for (int r = 0; r < iBlockCnt; r++)
	{
		const abyte* pStart = (const abyte*)pData + r * iVPageSize * pitch;

		for (int c = 0; c < iBlockCnt; c++)
		{
			const abyte* pLine = pStart;
			for (int i = 0; i < iVPageSize; i++)
			{
				file.Write(pLine, iBlockPitch);
				pLine += pitch;
			}

			pStart += iBlockPitch;
		}
	}

	return true;
}

///////////////////////////////////////////////////////////////////////////
//	Implement of CVTextureStream
///////////////////////////////////////////////////////////////////////////

bool CVTextureStream::GenVirtualTexture(const char* szDDSFile, int iVTexSize, int iVPageSize, int iIndirTexSize, int iOriTexSize)
{
	auint16 szWFile[MAX_PATH];
	a_GB2312ToUTF16(szWFile, szDDSFile, MAX_PATH);

	//	Load dds file
	DirectX::TexMetadata metadata;
	DirectX::ScratchImage image;
	HRESULT hr = DirectX::LoadFromDDSFile((LPCWSTR)szWFile, DirectX::DDS_FLAGS_FORCE_RGB, &metadata, image);
	if (FAILED(hr))
	{
		glb_OutputLog("CVTextureStream::GenVirtualTexture, failed to load texture [%s]", szDDSFile);
		return false;
	}

	MyAssert(metadata.arraySize == 1);
	MyAssert(iVTexSize == metadata.width && iVTexSize == metadata.height);
	MyAssert(iVTexSize % iVPageSize == 0);
	MyAssert(metadata.format == DXGI_FORMAT_R8G8B8A8_UNORM || metadata.format == DXGI_FORMAT_R8G8B8A8_UINT);

	//	Calculate vt's mipmap count
	int iMipmap = 0;
	for (int i = 1; i <= iIndirTexSize; i <<= 1)
	{
		iMipmap++;
	}

	//	Create virtual texture file
	char szVTFile[MAX_PATH];
	strcpy(szVTFile, szDDSFile);
	af_ChangeFileExt(szVTFile, MAX_PATH, ".vt");

	AFileWrapper file(szVTFile, "wb+");
	if (!file.GetFile())
	{
		glb_OutputLog("CVTextureStream::GenVirtualTexture, failed to create vt file [%s]", szVTFile);
		return false;
	}

	const int iPixelBytes = 4;
	const int iOriTexInRow = iVTexSize / iOriTexSize;

	//	write file header
	VTFILE_HEADER header;
	memset(&header, 0, sizeof(header));
	header.ver = VTFILE_VERSION;
	header.iVTexSize = iVTexSize;
	header.iVPageSize = iVPageSize;
	header.iIndirTexSize = iIndirTexSize;
	header.iPixelBytes = iPixelBytes;
	header.iMipmapCnt = iMipmap;
	header.iNumOriginTex = iOriTexInRow * iOriTexInRow;	//	TODO: this is just a testing value
	header.fmtVT = (int)metadata.format;
	file.Write(&header, sizeof(header));

	//	write original texture infos
	//	TODO: original texture infos should be generated by VT building tools, here we just
	//	write testing values by hard codes.
	int idTex = 0;
	for (int i = 0; i < iOriTexInRow; i++)
	{
		for (int j = 0; j < iOriTexInRow; j++)
		{
			CVTextureSystem::ORIGINAL_TEX tex;
			tex.idTex = idTex++;
			tex.scale = (float)iOriTexSize / iVTexSize;
			tex.off_u = j * tex.scale;
			tex.off_v = i * tex.scale;
			file.Write(&tex, sizeof(tex));
		}
	}

	//	write empty mipmap info table to hold place
	const auint64 offset_mip = file.GetPos();
	const int max_mip = 32;
	MyAssert(iMipmap <= max_mip);
	MIP_DATA aMipInfos[max_mip];
	memset(aMipInfos, 0, sizeof(aMipInfos));
	file.Write(&aMipInfos, sizeof(MIP_DATA) * iMipmap);

	//	Write mipmap data
	int iMipVTexSize = iVTexSize;
	for (int i = 0; i < iMipmap; i++)
	{
		MIP_DATA& mip = aMipInfos[i];
		mip.offset = file.GetPos();
		mip.iVPageCnt = iMipVTexSize / iVPageSize;

		const DirectX::Image* pImage = image.GetImage(i, 0, 0);
		WriteMipmapData(file, pImage->pixels, iMipVTexSize, iPixelBytes, (int)pImage->rowPitch, iVPageSize);

		mip.uDataSize = file.GetPos() - mip.offset;

		iMipVTexSize >>= 1;
	}

	//	Rewrite mipmap info table
	file.Seek(offset_mip, SEEK_SET);
	file.Write(&aMipInfos, sizeof(MIP_DATA) * iMipmap);
	file.Close();

	return true;
}

CVTextureStream::CVTextureStream() :
m_pVTSys(nullptr),
m_pFile(nullptr),
m_iMipmapCnt(0),
m_aMipInfos(nullptr)
{
}

CVTextureStream::~CVTextureStream()
{
}

bool CVTextureStream::Open(CVTextureSystem* pVTSys, const char* szFile)
{
	m_pFile = new AFileWrapper(szFile, "rb");
	if (!m_pFile || !m_pFile->GetFile())
		return false;

	m_pVTSys = pVTSys;

	//	read file header
	VTFILE_HEADER header;
	m_pFile->Read(&header, sizeof(header));

	pVTSys->m_iVTexSize = header.iVTexSize;
	pVTSys->m_iVPageSize = header.iVPageSize;
	pVTSys->m_iIndirMapSize = header.iIndirTexSize;
	pVTSys->m_iPixelBytes = header.iPixelBytes;
	pVTSys->m_iMipmapCnt = header.iMipmapCnt;
	pVTSys->m_iOriginalTexNum = header.iNumOriginTex;
	pVTSys->m_iPageDataSize = header.iVPageSize * header.iVPageSize * header.iPixelBytes;
	pVTSys->m_fmtVT = (DXGI_FORMAT)header.fmtVT;

	//	read original texture infos
	pVTSys->m_aOriTexInfo = new CVTextureSystem::ORIGINAL_TEX[header.iNumOriginTex];
	if (!pVTSys->m_aOriTexInfo)
	{
		Release();
		return false;
	}

	m_pFile->Read(pVTSys->m_aOriTexInfo, sizeof(CVTextureSystem::ORIGINAL_TEX) * header.iNumOriginTex);

	//	read mipmap info
	m_iMipmapCnt = header.iMipmapCnt;
	m_aMipInfos = new MIP_DATA[m_iMipmapCnt];
	if (!m_aMipInfos)
	{
		Release();
		return false;
	}

	m_pFile->Read(m_aMipInfos, sizeof(MIP_DATA) * m_iMipmapCnt);

	return true;
}

void CVTextureStream::Release()
{
	if (m_aMipInfos)
	{
		delete[] m_aMipInfos;
		m_aMipInfos = nullptr;
	}

	if (m_pFile)
	{
		m_pFile->Close();
		delete m_pFile;
		m_pFile = nullptr;
	}
}

bool CVTextureStream::ReadVPageByUV(float u, float v, int mipmap, abyte* pBuf)
{
	MyAssert(m_pFile);

	if (mipmap < 0 || mipmap >= m_iMipmapCnt)
	{
		MyAssert(mipmap >= 0 && mipmap < m_iMipmapCnt);
		return false;
	}

	a_Clamp(u, 0.0f, 1.0f);
	a_Clamp(v, 0.0f, 1.0f);

	//	size of vt on this mip level
	const MIP_DATA& mipinfo = m_aMipInfos[mipmap];
	int iVTSize = mipinfo.iVPageCnt * m_pVTSys->m_iVPageSize;
	int x = (int)(iVTSize * u / m_pVTSys->m_iVPageSize);
	int y = (int)(iVTSize * v / m_pVTSys->m_iVPageSize);

	if (!ReadVPage(x, y, mipmap, pBuf))
		return false;

	return true;
}

bool CVTextureStream::ReadVPage(int x, int y, int mipmap, abyte* pBuf)
{
	MyAssert(m_pFile);

	if (mipmap < 0 || mipmap >= m_iMipmapCnt)
	{
		MyAssert(mipmap >= 0 && mipmap < m_iMipmapCnt);
		return false;
	}

	const MIP_DATA& mipinfo = m_aMipInfos[mipmap];
	int iVTSize = mipinfo.iVPageCnt * m_pVTSys->m_iVPageSize;
	auint64 offset = mipinfo.offset + (y * mipinfo.iVPageCnt + x) * m_pVTSys->m_iPageDataSize;
	m_pFile->Seek(offset, SEEK_SET);

	if (!m_pFile->Read(pBuf, m_pVTSys->m_iPageDataSize))
	{
		return false;
	}

	return true;
}

